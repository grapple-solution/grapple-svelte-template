---
version: '3'
silent: true

vars:
  VALUES_YAML_PATH: "chart/values.yaml"
  GRAPI_INJECTION_FOLDER: "grapi"
  GRUIM_INJECTION_FOLDER: "gruim"
  BASE: "gras-deploy"
  CHART_FOLDER: "./chart"
  CHART_NAME: # use the current folder as the chart name
    sh: echo ${PWD##*/}
  CHART_NAME_SHORT: # use the current folder as the chart name
    sh: |
        string="${PWD##*/}"
        string="${string//[.\']/}"
        string="${string//[!a-zA-Z ]/ }"
        acronym=''
        for word in ${string}
        do
          acronym+="${word:0:4}"
        done
        echo "$acronym"
  AWS_REGION: "us-east-1"
  AWS_USERNAME: "AWS"
  AWS_REPO_URL: "oci://public.ecr.aws/p7h7z5g3"
  VERSION_FILE: "version.txt" 
  REGISTRY: "public.ecr.aws"
  GIT_HASH:
    sh: git log -n 1 --format=%h
  CURRENT_VERSION:
    sh: |
        cd {{.CHART_FOLDER}}
        # Check if version file exists
        if [ ! -f "{{.VERSION_FILE}}" ]; then
          # If version file does not exist, create it with initial version 0.1.0
          echo "0.1.0" > {{.VERSION_FILE}}
        fi
        CURRENT_VERSION=$(cat {{.VERSION_FILE}})
        echo ${CURRENT_VERSION}

env:
  OSTYPE:
    sh: bash -c 'echo $OSTYPE'

tasks:

  patch-values-file:
    desc: Gather and encode backend (grapi) and frontend (gruim) injections 
          and update values.yaml
    cmds:
      - echo "1) Checking if values.yaml exists..."
      - |
        if [ -f "{{.VALUES_YAML_PATH}}" ]; then
          echo "values.yaml found at {{.VALUES_YAML_PATH}}"
        else
          echo "ERROR: values.yaml not found at {{.VALUES_YAML_PATH}}"
          exit 1
        fi
      - echo "2) Processing grapi injections..."
      - |
        FOLDER={{.GRAPI_INJECTION_FOLDER}}
        BASE64=$(if [[ "$OSTYPE" == "darwin"* ]]; then echo "base64"; else echo "base64 -w 0"; fi)
        BASE="{{.BASE}}"  # Ensuring BASE is enclosed in quotes for full path reference
        if yq -e ".${BASE}.${FOLDER}" {{.VALUES_YAML_PATH}} >/dev/null; then
          for file_path in $(find ${FOLDER} -name "*.ts" -or \
            -name "*.sh" -or -name "*.bash"); do  
            group_name=$(echo ${file_path} | sed "s,${FOLDER}/,,g" | \
              cut -d/ -f1)
            file_name=$(echo ${file_path} | sed "s,${FOLDER}/,,g" | \
              cut -d/ -f2)
            file_extension=$(echo ${file_name##*.})
            injection_name=$(echo ${file_name} | sed \
              "s,.${group_name}.${file_extension},,g" | sed \
              "s,.${group_name::${#group_name}-1}.${file_extension},,g" | \
              sed "s,.${file_extension},,g")
            base64_content=$(cat ${file_path} | ${BASE64})  # Base64 on single line
            if [ "${file_name}" = "index.ts" ]; then continue; fi
            echo "patching: ${FOLDER} - ${group_name} - ${injection_name} - \
              ${file_name}"
            yq -i "del(.${BASE}.${FOLDER}.${group_name}[] | \
              select(.name == \"${injection_name}\"))" {{.VALUES_YAML_PATH}}
            yq -i ".${BASE}.${FOLDER}.${group_name} += [{\"name\": \
              \"${injection_name}\", \"content\": \"${base64_content}\"}]" \
              {{.VALUES_YAML_PATH}}
          done
        else
          echo "failed to add ${FOLDER} values..."
          exit 99
        fi

      - echo "3) Processing gruim injections..."
      - |
        FOLDER={{.GRUIM_INJECTION_FOLDER}}
        BASE64=$(if [[ "$OSTYPE" == "darwin"* ]]; then echo "base64"; else echo "base64 -w 0"; fi)
        BASE="{{.BASE}}"  # Ensuring BASE is enclosed in quotes for full path reference
        cm="custommodules"
        if yq -e ".${BASE}.${FOLDER}" {{.VALUES_YAML_PATH}} >/dev/null; then
          yq -i "del(.${BASE}.${FOLDER}.${cm}[])" {{.VALUES_YAML_PATH}}
          for file_path in $(find ${FOLDER}/shared -name "*.svelte"); do 
            group_name=$(echo ${file_path} | sed "s,${FOLDER}/,,g" | \
              cut -d/ -f1)
            file_name=$(echo ${file_path} | sed "s,${FOLDER}/,,g" | \
              cut -d/ -f2)
            file_extension=$(echo ${file_name##*.})
            injection_name=$(echo ${file_name} | sed \
              "s,.${group_name}.${file_extension},,g" | sed \
              "s,.${group_name::${#group_name}-1}.${file_extension},,g" | \
              sed "s,.${file_extension},,g")
            injection_name=$(echo ${file_name} | sed "s,.${file_extension},,g")
            base64_content=$(cat ${file_path} | ${BASE64})  # Base64 on single line
            if [ "${file_name}" = "index.ts" ]; then continue; fi
            echo "patching: ${FOLDER} - ${cm} - ${injection_name} - \
              ${file_name}"
            yq -i ".${BASE}.${FOLDER}.${cm} += [{\"name\": \
              \"${injection_name}\", \"content\": \"${base64_content}\"}]" \
              {{.VALUES_YAML_PATH}}
          done
        else
          echo "failed to add ${FOLDER} values..."
          exit 99
        fi


  version-bump:
    desc: Bump the version
    cmds:
      - |
        cd {{.CHART_FOLDER}}
        
        # Split the version into major, minor, and patch components
        IFS='.' read -r major minor patch <<< "{{.CURRENT_VERSION}}"
        
        # Increment the patch version
        patch=$((patch + 1))
        
        # If patch reaches 100, reset to 0 and increment minor version
        if [ "$patch" -ge 100 ]; then
          patch=0
          minor=$((minor + 1))
        fi
        
        # If minor reaches 100, reset to 0 and increment major version
        if [ "$minor" -ge 100 ]; then
          minor=0
          major=$((major + 1))
        fi
        
        NEW_VERSION="${major}.${minor}.${patch}"        
        echo $NEW_VERSION > {{.VERSION_FILE}}

  package-chart:
    desc: Package the Helm chart
    cmds:
      - |
        # rename the chart properly
        yq e -i '.name = "{{.CHART_NAME}}"' {{.CHART_FOLDER}}/Chart.yaml

        # run dependency update in order to prevent issue on the first build
        helm dep up chart

        # build the helm package
        helm package chart --version {{.CURRENT_VERSION}}

  push-chart-aws:
    desc: Push the packaged Helm chart to the repository
    env:
      AWS_ACCESS_KEY_ID: '{{.AWS_ACCESS_KEY_ID}}'
      AWS_SECRET_ACCESS_KEY: '{{.AWS_SECRET_ACCESS_KEY}}'
    cmds:
      - |
        AWS_ACCESS_KEY_ID={{.AWS_ACCESS_KEY_ID}}
        AWS_SECRET_ACCESS_KEY={{.AWS_SECRET_ACCESS_KEY}}
        aws ecr-public get-login-password \
          --region {{.AWS_REGION}} | helm registry login \
          --username {{.AWS_USERNAME}} \
          --password-stdin {{.REGISTRY}}
        aws ecr-public create-repository --repository-name {{.CHART_NAME}} --region {{.AWS_REGION}} 2>/dev/null || true
        helm push {{.CHART_NAME}}-{{.CURRENT_VERSION}}.tgz {{.AWS_REPO_URL}}

  deploy:
    desc: Deploy the Helm chart to the Grapple cluster
    env:
      STAGE: '{{.STAGE | default "prd"}}'
    cmds:
      - |
        cd {{.CHART_FOLDER}}
        if [ "${STAGE}" = "prd" ]; then
          NS_EXT=""
        else
          NS_EXT="-${STAGE}"
        fi
        helm upgrade --install {{.CHART_NAME}} {{.AWS_REPO_URL}}/{{.CHART_NAME}} --version {{.CURRENT_VERSION}} --namespace {{.CHART_NAME}}${NS_EXT} --create-namespace

  deploy-local:
    desc: Deploy the Helm chart to the Grapple cluster
    cmds:
      - |
        NS="{{.CHART_NAME_SHORT}}-{{.GIT_HASH}}"
        yq e -i '.version = "{{.CURRENT_VERSION}}"' {{.CHART_FOLDER}}/Chart.yaml
        yq e -i '.appVersion = "{{.CURRENT_VERSION}}"' {{.CHART_FOLDER}}/Chart.yaml
        helm upgrade --install {{.CHART_NAME}} {{.CHART_FOLDER}} --namespace "${NS}" --create-namespace

  build-package-push:
    desc: Build, package, and push the Helm chart in one step
    deps:
      - patch-values-file
      - package-chart
      - push-chart-aws